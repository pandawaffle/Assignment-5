### Gritty Details ###
These are in-depth explinations of my functions, with what code I have written for them thusfar, as well as reflections.

/*
	Default constructor
*/
	Lang();

/* 
	From-file Constructor: Expects an input file stream to one of the training or test files 
*/
	Lang::Lang(std::ifstream &infile){												
			string line;
			string body; body = "";		// need to define again?									
			char ch;
		while (getline(infile, line)) {												
			body += line;	
		} 	
		for (int i = 0; i < (int) body.length(); i++){
			ch = body[i];
			if (ch=='a' || ch=='b' || ch=='c' || ch=='d' || ch=='e' || ch=='f' || ch=='g' || ch=='h' || ch=='i' || ch=='j' ||
				ch=='k' || ch=='l' || ch=='m' || ch=='n' || ch=='o' || ch=='p' || ch=='q' || ch=='r' || ch=='s' || ch=='t' ||
				ch=='u' || ch=='v' || ch=='w' || ch=='x' || ch=='y' || ch=='z' || ch==' '){
				continue;
		}
		else {throw std::runtime_error("Bad characters in body");
		bool empty = (body.length <= 2);
		infile.close();																
	}

/* 
	Getter Methods: Each returns their respective object property 
*/

string Lang::getBody(){
	return body;
}
string Lang::getTitle(){
	return title;
}
bool Lang::getEmpty(){
	return empty;
}
vector<int> Lang::getTri_freq(){
	return tri_vec;
}
double Lang::getCos_sim(){
	return cos_sim;
}
	
/* 
	0-Vector Builder: Generates a vector of all possible trigrams with 0 for each frequency 
*/
	vector<int> Lang::0_vector();
	vector<base_27> vec_0;
	for (i=a; i<='qqq'; i++;){
		tri_vec_0.pushback(i);
	}
#no flipping idea
	
/* 
	Trigram Vector Builder: Starts with 0-Vector, but adds frequency to each trigram as it appears 
*/
	vector<int> Lang::trigram_vector(Lang langauge);
	

/* 
	Roman Alphabet to Base 27 Translator: Assigns values as needed to code Roman Alphabet letters and SPACE into base 27 characters 
*/
	translate_27(string trigram)
	
#Trigram frequency vector 
A vector of trigram frequencies (tri_freq) can be constructed for each lang object. Its values at each position will be base 10 (int), but its positions will be base 27.
	Let's call those positons tri_freq[XYZ].
The end goal is to increment a position on the frequency vector by 1 when it appears.
Working backwards, I now need to make XYZ. In the lecture example hexidecimal (base 16) was represented by 0-9 and a-f. 
I will need to make a translate_27 helper-function which, to reduce the amount of code I would need to write, would change *r-z & SPACE equal to 0-9. That way a-p can stay a-p.
	*q is the 17th letter of the alphabet, so r-z are the remaining 9 letters and SPACE makes 27 total.
A 3-character string 'trigram_s' would be recast as an intermediate null 'trigram_n' then recast as the three-digit base 27 number 'trigram_#'.
	I believe recasting as null will avoid errors.
Continuing to work backwards, I now need to get trigrams out of the body string.

#Trigrams
I want to use an approach I could not make work in Assignment 3 in the codon reader.
I want to build a string called trigram by adding together 3 smaller strings of length 1, each being a position in the original string.
	(This is opposed to the substring approach I used in Assignment 3)
	
for i = 0; i < i< (int) (((body.length()/3)*3) ; i++){
	trigram_s = body[i] + body[i+1] + body[i+2];
	trigram_s = translate_27(trigram_s);
	null trigram_n = trigram_s;
	int trigram_# = trigram_n;
	tri_freq[trigram_n] = tri_freq[trigram_n] + 1;
	trigram_s = "";
	trigram_n = "";     // How clear these? 
	trigram_# = "";		
}
This will ignore the last two trigrams, which would be incomplete.
	
/* 
	Cosine Similarity Calculator: After checking if the object was flagged to have an empty body, calculates the similarity between the training object and the test object 
*/
	double Lang::cosine_similarity(Lang langauge)	
	
	The cosine similarity function is a simple plug & chug using a for-loop. I designed this code in class the day it was presented:		
		for(i=0; i=(n-1); i++){
			sum_AB += (A[i])*(B[i]);
			sum_A^2 += (A[i])*(A[i]);
			sum_B^2 += (B[i])*(B[i]);
		}
		cos_sim = (sum_AB / (sqrt(sum_A^2)*sqrt(sum_B^2)));
	return cos_sim; 
I'll be sure to cast cos_sim as a double.
n-1 should be 26, if I understand it correctly.
I'll need to design a seperate piece of code to deal with the special 0 vector problem discussed in class.



/* 
	Find Maximum Similiarity: Compares the cosine similarities of each training object and then returns the title of the highest 
*/
	string Lang::max_sim(Lang training, Lang test)

the cos_sim function will have be called between every training file and the test file


if (getCos_sim.lang_target getCos_sim.lang_pool)) < guess_cos_diff){   
	guess_cos_diff = (abs(getCos_sim.lang_target)-abs(getCos_sim.lang_pool));
	lang_guess = lang_pool;
}

Early in lecture we designed a function called "findmax" that used a 'candidate' and a 'guess' to compare all elements in array against one another to find the largest number.
I will use the same approach to compare cosine similarity coeffecients via using getCos on each language object.
	I will have to be careful to design the training object for-loop to cycle up through argc-1 so that it does not include the cos_sim of the test object & itself in its findmax function.
Output after maximum cosine similarity selection will be simple, because I can output "guess.getTitle()".
	
	
	
	
	
	
	
	